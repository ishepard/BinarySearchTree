\documentclass[a4paper]{article}

\usepackage{fullpage}
\usepackage{url}
\usepackage{hyperref}
\usepackage{acronym}
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{float}
\usepackage[ruled,vlined]{algorithm2e}

\acrodef{BST}{Binary Search Tree}
\acrodef{CAS}{Compare-And-Set}

% ----------------------------------------------------------------------------
% Start the document
%
\begin{document}


\begin{centering}
~~~~~~~~~~~~~\\[-20mm]

  {
  \bfseries Master Degree in Computer Science\\[3mm]
  Concurrency\\[3mm]
  AA 2014-2015
  }\\[1mm]


  \vspace{0.5cm}
  {
  \Large \bfseries{An Implementation of a non-blocking Binary Search Tree in Java} \par
  }
  \vspace{0.2cm}
  {
  \small \bfseries{Project report} \par
  }
  \vspace{0.2cm}

  {Davide Spadini (id 164393)}

  \vspace{0.3cm}
\end{centering}



\section{Introduction}\label{introduction}
A non-blocking \ac{BST} is a binary search tree in which the three operations Find(key), Insert(key), and Delete(key) maybe invoked by concurrent threads.

The goal of this project is to implement a \ac{BST} in Java using the algorithm described in \cite{algorithm}. 
This algorithm is \emph{non-blocking} (starting from any configuration of any infinite asynchronous execution, with any number of crash failures, some operation always completes) and \emph{linearizable}. The full (and lengthy) proof of correctness appears in \cite{proof}.

\section{Usage} % (fold)
\label{sec:usage}

In order to compile the project, open the terminal in the root directory and digit:

\verb|javac -d bin src/*.java|
\\
\noindent
To run it, go in the \emph{bin} directory and digit:

\verb|java Main|
\\
\noindent
In the configuration that is used there are \textbf{5 threads}, concurrently performing 15 insert, 10 delete and 10 find.

\section{Output}
\label{sec:output}
When all the threads have finished to execute their operations, the program prints the resulting tree in two different formats:
\begin{compactitem}
  \item \textbf{OCaml syntax} Printed on the terminal
  \item \textbf{Dot format\footnote{see \url{http://www.graphviz.org}}} Saved on an external file \emph{tree.dot}
\end{compactitem}

\noindent
In order to build the graph starting from the \emph{dot} file, open the terminal in the root directory and launch:

\verb!dot tree.dot | gvpr -c -ftree.gv | neato -n -Tpng -o binarytree.png!
\\

In order to obtain a better result, in the command above I used an external script \emph{tree.gv} that enforces the horizontal node ordering.\footnote{All credits of this script goes to \emph{Emden R. Gansner}, script available at \url{https://mailman.research.att.com/pipermail/graphviz-interest/2010q2/007101.html}}
% \begin{compactitem}
%   \item \textbf{Thread 0}
%     \begin{compactitem}
%       \item insert 1
%       \item delete 1
%       \item insert 2
%       \item insert 7
%       \item find 15
%       \item delete 18
%     \end{compactitem}
%   \item \textbf{Thread 1}
%     \begin{compactitem}
%       \item insert 8
%       \item insert 3
%       \item delete 2
%       \item find 11
%       \item delete 1
%       \item find 1
%       \item find 20
%     \end{compactitem}
%   \item \textbf{Thread 2}
%     \begin{compactitem}
%       \item insert 10
%       \item insert 20
%       \item delete 25
%       \item insert 35
%       \item insert 40
%       \item delete 10
%       \item find 40
%     \end{compactitem}
%   \item \textbf{Thread 3}
%     \begin{compactitem}
%       \item insert 11
%       \item find 8
%       \item insert 22
%       \item insert 33
%       \item find 15
%       \item delete 44
%       \item delete 22
%       \item find 22
%     \end{compactitem}
%   \item \textbf{Thread 4}
%     \begin{compactitem}
%       \item insert 15
%       \item find 11
%       \item insert 25
%       \item insert 35
%       \item delete 25
%       \item delete 20
%       \item find 8
%     \end{compactitem}
% \end{compactitem}
% section usage (end)

\section{Implementation} % (fold)
\label{sec:implementation}
As explained before, the aim of this project is to give an implementation of a non-blocking \ac{BST} using the algorithm described in \cite{algorithm}, so I will not discuss the algorithm but only the implementation of it.

\noindent
The main classes are the following:
\begin{compactitem}
  \item \textbf{Leaf} The node with the key
  \item \textbf{Internal} The node used to traverse the tree
  \item \textbf{Update} Contains the state of the node and an \emph{Info} record.
  \item \textbf{IInfo} When an insert is performed, the thread create an IInfo record in order to save enough information so that another thread that encounters the flagged node can complete the operation
  \item \textbf{DInfo} The same as the IInfo, just for the delete function
  \item \textbf{BinarySearchTree} The real program, contains all the functions of the \ac{BST}
  \item \textbf{Main} The main of the program. In this class are instantiated 5 threads and 1 \ac{BST}
\end{compactitem}

\noindent

Furthermore there are minor class, but for more information I remind the reader to Sec.[\ref{sec:javadoc}]

\subsection{Implementation Details}
\begin{itemize}
  \item \textbf{\ac{CAS}} The non-blocking algorithm uses \ac{CAS}\footnote{for more details see \url{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html}} in order to update atomically some information (i.e. change the left child pointer of a node from one node to another one). Another point in which \ac{CAS} is used is when we need to change the \emph{Update} field of a node, and here is where the problem comes out: in the algorithm they \ac{CAS} a record composed by two field (state and info), but in Java there is not this possibility. So instead of using a simple reference I use an \emph{AtomicReference$<$Update$>$}. At the beginning of the functions that use the \ac{CAS} on that field (i.e. insert or delete) I copy the reference on a local variable (a sort of \emph{snapshot}, in this way I'm sure that no-one can change it during the execution of the function), and then I \ac{CAS} the current value of the field with the \emph{snapshot} that I took before.
  \item \textbf{TreeThread class} I use this class in order to give a sequence of operations to the threads. The list of operations are passed by parameters in form of a tuple $<$action, value$>$ (i.e. $<$insert, 4 $>$). When a thread completes all the operations, it exits.
  \item \textbf{Output in OCaml syntax} In order to print the tree with this syntax, I use the \emph{toString()} function recursively from the \emph{Root} until the leafs. The implementation is simply:

  \verb|Node(key , left.toString(), right.toString())|
  \item \textbf{Dot format} There is a function \emph{toDot()} which writes the tree according to the dot format in an external file \emph{tree.dot}. This function is recursive, and it is called starting from the root. The result is a directed graph, in which the internal nodes are represented by black circles, and the leafs are represented by blue squares.
\end{itemize}
\noindent
All the other functions are the identical representation in Java of the algorithm desribed in \cite{algorithm}. In the next sections we will briefly see them, for a complete overview see the Javadoc in Sec.[\ref{sec:javadoc}]. 

\subsection{Find}
This function takes in input a key, and it uses the \emph{search} method to traverse the tree searching for the leaf with that key. If this leaf exists return it, otherwise return \emph{null}.

\subsection{Insert}
This function takes in input a key and it inserts a new leaf in the tree with that key. The main steps are the following:
\begin{compactitem}
  \item First of all it checks if the key already exists (duplicated keys are not admitted in the search tree)
  \item It checks if there are other pending operations on the same nodes that he needs to operate on, in this case it tries to complete them, otherwise it builds a new structure with the key. 
  \item After that it tries to change the state of its parent to ``IFLAG'' (inform other processes that an insert is being performed)
  \begin{compactitem}
    \item If it fails, it helps the operation that has flagged or marked the parent, if any, and begins a new attempt.
    \item If it succeeds, it completes the insertion.
  \end{compactitem}
\end{compactitem}

\subsection{Delete}
This function takes in input a key and it delete the corresponding leaf from the tree. The main steps are the following:
\begin{compactitem}
  \item First calls the \emph{search} method to find the leaf to be deleted, if it fails returns False.
  \item If some other operation has already flagged or marked the parent or grandparent, it helps that operation complete and then begins over with a new attempt.
  \item Otherwise, it attempts to set the flag of the grandparent to ``DFLAG'' 
    \begin{compactitem}
      \item If this fails, it helps the operation that has flagged or marked the grandparent, if any, and then begins a new attempt
      \item If the ``DFLAG'' is successful, it tries to complete the deletion.
    \end{compactitem}
\end{compactitem}

In the delete function we have to ``DFLAG'' the grandparent of the node, and ``MARK'' the parent of the node. Due to the fact that this 2 steps may be not being executed sequentially, what could happens is that the first step is completed correctly and second one fails (because for example another process changes the state of the parent). So, in this case, there is the possibility to reset the state of the grandparent from ``DFLAG'' to ``CLEAN'' and restart again all the procedure.

% section implementation (end)

\section{Javadoc}
\label{sec:javadoc}


\section{Test}
\label{sec:test}

% section program_evaluation (end)

\section{Conclusions and further works}
\label{sec:conclusions}


% section conclusions (end)

\bibliographystyle{plain}

\begin{thebibliography}{5}

\bibitem{algorithm} Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel
\textit{Non-blocking binary search trees} Available at
\url{http://dl.acm.org/citation.cfm?doid=1835698.1835736}

\bibitem{proof} Faith Ellen, Panagiota Fatourou, Eric Ruppert, Franck van Breugel
\textit{Non-blocking binary search trees} Technical Report CSE-2010-04, York University, 2010.

\end{thebibliography}

\end{document}
